# -*- coding: utf-8 -*-
"""Simulated Annealing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/172rHB14fWnclxUScKeu7Xm10epMb53ZW
"""

import random
import matplotlib.pyplot as plt
import time
from common.geracao_produto import GeracaoDeProdutos

# Cria a Classe que implementa o algoritmo de Simulated Annealing
class SimulatedAnnealing:
    def __init__(self, produtos, limite_espacos):
        # Inicializa os atributos da classe
        self.produtos = produtos  # Lista de produtos disponíveis
        self.limite_espacos = limite_espacos  # Limite de espaço permitido
        self.num_produtos = len(produtos)  # Número de produtos
        self.melhor_solucao = None  # Armazena a melhor solução encontrada
        self.melhor_valor = 0  # Armazena o melhor valor total alcançado

    # Função que gera uma solução inicial aleatória
    def gerar_solucao_inicial(self):
        solucao = [random.choice(["0", "1"]) for _ in range(self.num_produtos)]
        return solucao

    # Função que avalia a solução, calculando o valor total e espaço ocupado
    def avaliar_solucao(self, solucao):
        valor_total = 0
        espaco_total = 0
        for i in range(len(solucao)):
            if solucao[i] == "1":  # Se o produto for selecionado ("1"), soma seu valor e espaço
                valor_total += self.produtos[i].valor
                espaco_total += self.produtos[i].espaco
        if espaco_total > self.limite_espacos:  # Verifica se a solução excede o limite de espaço
            return 0  # Penaliza a solução se o limite for excedido
        return valor_total  # Retorna o valor total da solução

    # Função usada para gerar um vizinho (solução adjacente) ao alterar um produto aleatório
    def vizinho(self, solucao_atual):
        vizinho = solucao_atual[:]  # Copia a solução atual
        index = random.randint(0, self.num_produtos - 1)  # Seleciona um índice aleatório
        # Alterna o estado do produto selecionado (de "0" para "1" ou vice-versa)
        vizinho[index] = "1" if solucao_atual[index] == "0" else "0"
        return vizinho

    # Executa o algoritmo do Simulated Annealing
    def simulated_annealing(self, max_iter):
        solucao_atual = self.gerar_solucao_inicial()  # Gera a solução inicial
        melhor_solucao = solucao_atual[:]  # Armazena a melhor solução encontrada
        melhor_valor = self.avaliar_solucao(solucao_atual)  # Avalia a solução inicial

        historico_valores = []  # Lista para armazenar a evolução dos valores

        # Repete até atingir o número máximo definido.
        for _ in range(max_iter):
            nova_solucao = self.vizinho(solucao_atual)  # Gera uma nova solução vizinha
            valor_nova_solucao = self.avaliar_solucao(nova_solucao)  # Avalia a nova solução

            # Se a nova solução for melhor, atualiza a melhor solução e o melhor valor
            if valor_nova_solucao > melhor_valor:
                melhor_solucao = nova_solucao[:]
                melhor_valor = valor_nova_solucao

            solucao_atual = nova_solucao  # Atualiza a solução atual para a nova
            historico_valores.append(melhor_valor)  # Armazena o valor atual no histórico

        self.melhor_solucao = melhor_solucao  # Armazena a melhor solução final
        self.melhor_valor = melhor_valor  # Armazena o melhor valor final
        return historico_valores  # Retorna o histórico dos valores

    # Plota a evolução do valor durante as iterações
    def plot_resultados(self, historico_valores, execution_time):
        """ Plota a evolução do valor durante o Simulated Annealing """
        plt.plot(historico_valores)  # Plota a lista de valores ao longo das iterações
        plt.title(f'Evolução do valor durante o Simulated Annealing\nTempo de Execução: {execution_time:.2f} segundos')  # Título do gráfico
        plt.xlabel('Iterações')  # Rótulo do eixo X
        plt.ylabel('Valor Total')  # Rótulo do eixo Y
        plt.show()  # Exibe o gráfico

    # Retornar os produtos selecionados na melhor solução
    def produtos_selecionados(self):
        """ Retorna os produtos selecionados na melhor solução """
        produtos_escolhidos = []
        for i in range(self.num_produtos):  # Percorre a lista de produtos
            if self.melhor_solucao[i] == "1":  # Se o produto foi selecionado na melhor solução
                produtos_escolhidos.append(self.produtos[i])  # Adiciona o produto à lista
        return produtos_escolhidos

def main():
    geracao = GeracaoDeProdutos()
    produtos = geracao.gerar_lista_produtos()
    limite_espacos = 3
    max_iter = 3000

    sa = SimulatedAnnealing(produtos, limite_espacos)

    start_time = time.time()
    historico_valores = sa.simulated_annealing(max_iter)
    end_time = time.time()
    execution_time = end_time - start_time

    print(f'Melhor solução encontrada: {sa.melhor_solucao}')
    print(f'Valor total: {sa.melhor_valor:.2f}')

    produtos_escolhidos = sa.produtos_selecionados()
    print("Produtos selecionados:")
    for produto in produtos_escolhidos:
        print(f'{produto.nome} - Espaço: {produto.espaco:.5f}, Valor: {produto.valor:.2f}')

    sa.plot_resultados(historico_valores, execution_time)

if __name__ == "__main__":
    main()